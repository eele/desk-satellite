#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "esp_rom_sys.h"

static const char *TAG = "PAJ7620_POLLING";

// --- I2C 引脚配置 ---
#define I2C_MASTER_SCL_IO           20      // SCL 引脚
#define I2C_MASTER_SDA_IO           21      // SDA 引脚
#define I2C_MASTER_NUM              0
#define I2C_MASTER_FREQ_HZ          400000
#define PAJ7620_SENSOR_ADDR         0x73

// --- 寄存器地址 ---
#define PAJ_REG_PART_ID_L           0x00
#define PAJ_REG_PART_ID_H           0x01
#define PAJ_REG_GESTURE_RESULT_L    0x43    // 手势结果寄存器
#define PAJ_BANK_SELECT             0xEF

// --- PAJ7620 完整初始化数组 (必要) ---
// 包含增益、积分时间等光学参数校准，缺少这些会导致识别极差
const uint8_t init_array[][2] = {
    {0xEF,0x00},
	{0x32,0x29},
	{0x33,0x01},
	{0x34,0x00},
	{0x35,0x01},
	{0x36,0x00},
	{0x37,0x07},
	{0x38,0x17},
	{0x39,0x06},
	{0x3A,0x12},
	{0x3F,0x00},
	{0x40,0x02},
	{0x41,0xFF},
	{0x42,0x01},
	{0x46,0x2D},
	{0x47,0x0F},
	{0x48,0x3C},
	{0x49,0x00},
	{0x4A,0x1E},
	{0x4B,0x00},
	{0x4C,0x20},
	{0x4D,0x00},
	{0x4E,0x1A},
	{0x4F,0x14},
	{0x50,0x00},
	{0x51,0x10},
	{0x52,0x00},
	{0x5C,0x02},
	{0x5D,0x00},
	{0x5E,0x10},
	{0x5F,0x3F},
	{0x60,0x27},
	{0x61,0x28},
	{0x62,0x00},
	{0x63,0x03},
	{0x64,0xF7},
	{0x65,0x03},
	{0x66,0xD9},
	{0x67,0x03},
	{0x68,0x01},
	{0x69,0xC8},
	{0x6A,0x40},
	{0x6D,0x04},
	{0x6E,0x00},
	{0x6F,0x00},
	{0x70,0x80},
	{0x71,0x00},
	{0x72,0x00},
	{0x73,0x00},
	{0x74,0xF0},
	{0x75,0x00},
	{0x80,0x42},
	{0x81,0x44},
	{0x82,0x04},
	{0x83,0x20},
	{0x84,0x20},
	{0x85,0x00},
	{0x86,0x10},
	{0x87,0x00},
	{0x88,0x05},
	{0x89,0x18},
	{0x8A,0x10},
	{0x8B,0x01},
	{0x8C,0x37},
	{0x8D,0x00},
	{0x8E,0xF0},
	{0x8F,0x81},
	{0x90,0x06},
	{0x91,0x06},
	{0x92,0x1E},
	{0x93,0x0D},
	{0x94,0x0A},
	{0x95,0x0A},
	{0x96,0x0C},
	{0x97,0x05},
	{0x98,0x0A},
	{0x99,0x41},
	{0x9A,0x14},
	{0x9B,0x0A},
	{0x9C,0x3F},
	{0x9D,0x33},
	{0x9E,0xAE},
	{0x9F,0xF9},
	{0xA0,0x48},
	{0xA1,0x13},
	{0xA2,0x10},
	{0xA3,0x08},
	{0xA4,0x30},
	{0xA5,0x19},
	{0xA6,0x10},
	{0xA7,0x08},
	{0xA8,0x24},
	{0xA9,0x04},
	{0xAA,0x1E},
	{0xAB,0x1E},
	{0xCC,0x19},
	{0xCD,0x0B},
	{0xCE,0x13},
	{0xCF,0x64},
	{0xD0,0x21},
	{0xD1,0x0F},
	{0xD2,0x88},
	{0xE0,0x01},
	{0xE1,0x04},
	{0xE2,0x41},
	{0xE3,0xD6},
	{0xE4,0x00},
	{0xE5,0x0C},
	{0xE6,0x0A},
	{0xE7,0x00},
	{0xE8,0x00},
	{0xE9,0x00},
	{0xEE,0x07},
	{0xEF,0x01},
	{0x00,0x1E},
	{0x01,0x1E},
	{0x02,0x0F},
	{0x03,0x10},
	{0x04,0x02},
	{0x05,0x00},
	{0x06,0xB0},
	{0x07,0x04},
	{0x08,0x0D},
	{0x09,0x0E},
	{0x0A,0x9C},
	{0x0B,0x04},
	{0x0C,0x05},
	{0x0D,0x0F},
	{0x0E,0x02},
	{0x0F,0x12},
	{0x10,0x02},
	{0x11,0x02},
	{0x12,0x00},
	{0x13,0x01},
	{0x14,0x05},
	{0x15,0x07},
	{0x16,0x05},
	{0x17,0x07},
	{0x18,0x01},
	{0x19,0x04},
	{0x1A,0x05},
	{0x1B,0x0C},
	{0x1C,0x2A},
	{0x1D,0x01},
	{0x1E,0x00},
	{0x21,0x00},
	{0x22,0x00},
	{0x23,0x00},
	{0x25,0x01},
	{0x26,0x00},
	{0x27,0x39},
	{0x28,0x7F},
	{0x29,0x08},
	{0x30,0x03},
	{0x31,0x00},
	{0x32,0x1A},
	{0x33,0x1A},
	{0x34,0x07},
	{0x35,0x07},
	{0x36,0x01},
	{0x37,0xFF},
	{0x38,0x36},
	{0x39,0x07},
	{0x3A,0x00},
	{0x3E,0xFF},
	{0x3F,0x00},
	{0x40,0x77},
	{0x41,0x40},
	{0x42,0x00},
	{0x43,0x30},
	{0x44,0xA0},
	{0x45,0x5C},
	{0x46,0x00},
	{0x47,0x00},
	{0x48,0x58},
	{0x4A,0x1E},
	{0x4B,0x1E},
	{0x4C,0x00},
	{0x4D,0x00},
	{0x4E,0xA0},
	{0x4F,0x80},
	{0x50,0x00},
	{0x51,0x00},
	{0x52,0x00},
	{0x53,0x00},
	{0x54,0x00},
	{0x57,0x80},
	{0x59,0x10},
	{0x5A,0x08},
	{0x5B,0x94},
	{0x5C,0xE8},
	{0x5D,0x08},
	{0x5E,0x3D},
	{0x5F,0x99},
	{0x60,0x45},
	{0x61,0x40},
	{0x63,0x2D},
	{0x64,0x02},
	{0x65,0x96},
	{0x66,0x00},
	{0x67,0x97},
	{0x68,0x01},
	{0x69,0xCD},
	{0x6A,0x01},
	{0x6B,0xB0},
	{0x6C,0x04},
	{0x6D,0x2C},
	{0x6E,0x01},
	{0x6F,0x32},
	{0x71,0x00},
	{0x72,0x01},
	{0x73,0x35},
	{0x74,0x00},
	{0x75,0x33},
	{0x76,0x31},
	{0x77,0x01},
	{0x7C,0x84},
	{0x7D,0x03},
	{0x7E,0x01},
};
#define INIT_ARRAY_SIZE (sizeof(init_array) / sizeof(init_array[0]))

// --- I2C 基础读写函数 ---

static esp_err_t i2c_write_byte(uint8_t reg_addr, uint8_t data) {
    uint8_t write_buf[2] = {reg_addr, data};
    return i2c_master_write_to_device(I2C_MASTER_NUM, PAJ7620_SENSOR_ADDR, write_buf, sizeof(write_buf), 1000 / portTICK_PERIOD_MS);
}

static esp_err_t i2c_read_byte(uint8_t reg_addr, uint8_t *data) {
    return i2c_master_write_read_device(I2C_MASTER_NUM, PAJ7620_SENSOR_ADDR, &reg_addr, 1, data, 1, 1000 / portTICK_PERIOD_MS);
}

// --- 传感器初始化 ---

// ... 其他 I2C 定义保持不变 ...

static esp_err_t paj7620_init(void) {
    uint8_t data = 0;
    esp_err_t ret = ESP_OK;

    ESP_LOGI(TAG, "Starting PAJ7620 Init Sequence...");

    // --- 步骤 1: 硬件上电等待 ---
    // 传感器上电后需要几毫秒稳定电压
    vTaskDelay(pdMS_TO_TICKS(20));

    // --- 步骤 2: 唤醒传感器 (关键!) ---
    // 读取一次 0x00 (Part ID) 可以唤醒处于休眠状态的传感器
    // 即使这次读取失败也没关系，关键是发送 I2C 信号唤醒它
    i2c_read_byte(0x00, &data);

    // 唤醒后必须等待至少 10ms，让内部时钟稳定，否则后续写入无效
    vTaskDelay(pdMS_TO_TICKS(20));

    // --- 步骤 3: 确认 ID (确认唤醒成功) ---
    // 切换到 Bank 0
    i2c_write_byte(PAJ_BANK_SELECT, 0x00);

    ret = i2c_read_byte(PAJ_REG_PART_ID_L, &data);
    if (ret != ESP_OK || data != 0x20) {
        ESP_LOGE(TAG, "ID Check Failed! Addr: 0x73? Wiring? (Data: 0x%02x)", data);
        return ESP_FAIL;
    }

    i2c_read_byte(PAJ_REG_PART_ID_H, &data);
    if (data != 0x76) return ESP_FAIL;

    ESP_LOGI(TAG, "Hardware Found (ID: 0x7620). Writing Config...");

    // --- 步骤 4: 写入初始化数组 (带延时) ---
    // ESP32 I2C 很快，PAJ7620 DSP 很慢。必须降速写入。
    for (int i = 0; i < INIT_ARRAY_SIZE; i++) {
        ret = i2c_write_byte(init_array[i][0], init_array[i][1]);
        if (ret != ESP_OK) {
            ESP_LOGE(TAG, "Write Array Failed at index %d", i);
            return ret;
        }
        // 【关键修复】每写一个字节，微秒级延时，防止 FIFO 溢出
        esp_rom_delay_us(100);
    }

    // --- 步骤 5: 最终使能 (小心翼翼版) ---

    // 5.1 再次强制切回 Bank 0 (防止数组最后没切回来)
    i2c_write_byte(PAJ_BANK_SELECT, 0x00);
    vTaskDelay(pdMS_TO_TICKS(50)); // 等 Bank 切换稳

    // 5.2 写入使能命令
    // ret = i2c_write_byte(0x72, 0x01);
    // if (ret != ESP_OK) {
    //     ESP_LOGE(TAG, "Write  Failed ");
    //     return ret;
    // }

    // 5.3 【关键】给 DSP 时间去加载配置并置位 Bit 0
    // 很多时候失败是因为这里没延时就马上去读状态了
    // vTaskDelay(pdMS_TO_TICKS(500));

    // --- 步骤 6: 最终状态校验 ---

    // 读取 0x40 System Flag
    // uint8_t flag = 0;
    // i2c_read_byte(0x40, &flag);
    //
    // ESP_LOGI(TAG, "Final Check Reg 0x40: 0x%02x", flag);
    //
    // // 检查 Bit 0 (Init Success)
    // if ((flag & 0x01) == 0) {
    //     // 如果还是失败，尝试“软复位”策略（死马当活马医）
    //     ESP_LOGW(TAG, "Still not initialized. Retrying Enable...");
    //     i2c_write_byte(0x72, 0x01);
    //     vTaskDelay(pdMS_TO_TICKS(50));
    //     i2c_read_byte(0x40, &flag);
    //     if ((flag & 0x01) == 0) {
    //         ESP_LOGE(TAG, "Sensor Init Failed completely. (Flag: 0x%02x)", flag);
    //         return ESP_FAIL;
    //     }
    // }

    ESP_LOGI(TAG, "PAJ7620 Init SUCCESS! Ready.");
    return ESP_OK;
}

// --- 轮询任务 ---

void gesture_polling_task(void *arg) {
	uint8_t gesture_data = 0;
	esp_err_t ret;

	while (1) {
		// 读取手势状态寄存器 (0x43)
		// 如果没有手势，该寄存器为 0x00
		ret = i2c_read_byte(PAJ_REG_GESTURE_RESULT_L, &gesture_data);

		if (ret == ESP_OK && gesture_data != 0) {
			switch (gesture_data) {
				case 0x01: ESP_LOGI(TAG, "Up (上)"); break;
				case 0x02: ESP_LOGI(TAG, "Down (下)"); break;
				case 0x04: ESP_LOGI(TAG, "Left (左)"); break;
				case 0x08: ESP_LOGI(TAG, "Right (右)"); break;
				case 0x10: ESP_LOGI(TAG, "Forward (前)"); break;
				case 0x20: ESP_LOGI(TAG, "Backward (后)"); break;
				case 0x40: ESP_LOGI(TAG, "Clockwise (顺时针)"); break;
				case 0x80: ESP_LOGI(TAG, "Anti-Clockwise (逆时针)"); break;
				default:   ESP_LOGW(TAG, "Unknown: 0x%02x", gesture_data); break;
			}

			// 检测到手势后，稍作延时避免重复读取同一个动作
			vTaskDelay(pdMS_TO_TICKS(200));
		} else {
			// 如果没有检测到手势，或者读取失败，稍微休息一下
			// 100ms 是个不错的轮询间隔，太快占用 I2C 总线，太慢会漏掉动作
			vTaskDelay(pdMS_TO_TICKS(100));
		}
	}
}

void app_main(void) {
    // 1. 初始化 I2C
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    i2c_param_config(I2C_MASTER_NUM, &conf);
    i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0);

    // 2. 初始化传感器
    if (paj7620_init() == ESP_OK) {
        // 3. 创建轮询任务
        xTaskCreate(gesture_polling_task, "gesture_poll", 4096, NULL, 5, NULL);
    } else {
        ESP_LOGE(TAG, "Sensor init failed. Check wiring!");
    }
}